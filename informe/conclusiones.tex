\section{Conclusiones}

En este trabajo se presentaron tres técnicas distintas que permiten resolver el problema de NPM. El algoritmo de \textit{Fuerza Bruta} es poco eficiente temporalmente ya que para un número relativamente pequeño de locales ($n=30$) el tiempo de ejecución se hace excesivamente elevado para todos los casos. Esto se ve mejorado en \textit{Backtracking} mediante el uso de \textit{podas}, donde la máxima performace se alcanza con una combinación de podas por factibilidad y optimalidad, permitiendo reducir el tiempo significativamente, en especial para los tipos de instancias favorables para las podas. Finalmente, el algoritmo de \textit{Programación Dinámica} es el que presenta un menor impacto en su tiempo de ejecución aumentando considerablemente el $n$, pero lo hace con un gran costo adicional en memoria. Además, pasa a depender del límite de contagio $M$, lo que hace que para valores elevados no sea la mejor opción.

Una línea de trabajo a futuro es ver si para algún tamaño $n$ de la secuencia de locales empieza a presentar mejores resultados precalcular los valores utilizados en la poda por optimalidad. Además, podrían implementarse otras estructuras para realizar la memoización en el caso de programación dinámica, tal podría ser el caso de mitigar el efecto de matrices ralas, que en la implementación utilizada en este trabajo llevarían a un gran desperdicio de memoria y tiempo de ejecución en su inicialización. 

Sería interesante también explorar alguna potencial mejora en la poda por optimilidad utilizada, dado que se decidió usar un algoritmo bastante simple en este trabajo. En lugar de contabilizar todos los locales que falta por recorrer, se podría pensar alguna estrategia golosa que permita reducir los tiempos de ejecución que quizás cobren relevancia frente a instancias más complejas.